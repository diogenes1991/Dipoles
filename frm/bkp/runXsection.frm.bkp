#-
#:SmallSize 50M
#:LargeSize 200M
#:ScratchSize 500M
#:MaxTermSize 5M
off statistics;
#include declarations.h
#include config.inc

s Pi;

#include `leftDiagDefFile' # global
#define firstl "`first'"
#define lastl  "`last'"
#if `subsetNLODiagrams' == 1
    #define firstl "`subsetfirst'"
    #define lastl "`subsetlast'"
#endif

cf SMEl, SMEr, SimpSMEl, SimpSMEr;
cf coll, colr;
table,sparse, SME(2);
table,sparse, fullSME(1);
table,sparse, col(2);
table,sparse, LOpart(2);
#include `idDir'/fullSMEsNull.id
#include `idDir'/ColorProducts.id
.global

#include `idDir'/LOdef.id
.store
dimension d;

#do i = `firstl', `lastl'
    #message d`i'
    load sav/simpdiagl`i'.sav;
    .store
    #message mult2
    g dd`i' =  simpdiagl`i'*LOdef*`xsectNorm';
*   spin and color average
    mul cOlNR^(-`nInQuarks');
    mul cOlNA^(-`nInGluons');
    mul 2^(-`nInFermions');
*   added by Seth; may need to change for d dimensions
    mul 2^(-`nInBosons');
*(1+`nInBosons'*ep+`nInBosons'*(`nInBosons'+1)/2*ep^2);

*   added by Seth; multiply by renormalization factor if on
    #if `renorm' == 1
        mul `renormFactor';
    #endif

    b colr, coll;
    .sort
    Keep Brackets;
    #message Colors
    id coll(n1?)*colr(n2?) = col(n1,n2);

    b cOlNR, cOlNA, cOlcA, cOlcR;
    .sort
    Keep Brackets;
    id cOlcR^n? = CF^n;
    id cOlcA^n? = CA^n;
    id cOlNR^n? = NF^n;
    id cOlNA^n? = NA^n;

    b CF, CA, NF, NA, color;
    .sort 
    Keep Brackets;

    argument;
        id CF^n1? = (4/3)^n1;
        id CA^n1? = 3^n1;
        id NA^n1? = 8^n1;
        id NF^n1? = 3^n1;
    endargument;
    id CF^n1? = (4/3)^n1;
    id CA^n1? = 3^n1;
    id NA^n1? = 8^n1;
    id NF^n1? = 3^n1;

    id color(n1?)*CF^n2? = color(n1*CF^n2);
    id color(n1?)*CA^n2? = color(n1*CA^n2);
    id color(n1?)*NA^n2? = color(n1*NA^n2);
    id color(n1?)*NF^n2? = color(n1*NF^n2);
    id color(n1?) = n1;

    b SMEl, SimpSMEl, LOpart;
    .sort 
    Keep Brackets;
    #message SMEs
    id SimpSMEl(n1?)*LOpart(n2?) = fullSME(n1*`nLOparts' + n2);
*    id SMEl(n1?)*LOpart(n2?) = sum_(n,0,2,fullSME(n1,n2,n)*ep^n);
    b TI;
    .sort
    Keep Brackets;

*    id TI(?args) = sum_(n,-2,0,TI(?args,n)*ep^n);

    b DS, p1, p2, p3, p4, p5, p6;
    .sort
    Keep Brackets;

* Changed by Seth: probable incorrect sign on m term below
    repeat;
        id DS(p1?, p2?, m?, n?)*p1?.p2? = 1/2*DS(p1,p2,m,n-1) - 1/2*(p1.p1 + p2.p2 - m^2)*DS(p1,p2,m,n);
        id DS(p1?, ?args, m?, 0) = 1;
    endrepeat;

    repeat id DS(p1?,p2?,?args,m?, n?) = DS(p1 + p2, ?args,m, n);
    repeat id DS(p1?, m?,n1?)*DS(p1?,m?, n2?) = DS(p1,m,n1+n2);

    #include processSpecific.inc;

    b p1,p2,p3,p4,p5,p6;
    .sort
    Keep Brackets;
    id p1?.p2? = SS(p1,p2);
*
*    #do i = 1,6
*        #do j = `i',6
*            #do n = 2,5
*                id (p`i'.p`j')^`n' = p`i'p`j'pow`n';
*            #enddo
*            id p`i'.p`j' = p`i'p`j';
*        #enddo
*    #enddo
    b sDS;
    .sort
    Keep Brackets;
    id sDS(?args) = DS(?args);
    b DS;
    .sort 
    Keep Brackets;
    id DS(p1?,m1?,n1?) = DS(p1,m1,1)^n1;
    b DS;
    .sort
    Keep Brackets;
    normalize, (0), DS;
    repeat id DS(p1?, m?, n1?)*DS(p1?,m?, n2?) = DS(p1,m,n1+n2);
    #include processSpecific.inc

    b d;
    .sort
    format mathematica;
    Keep Brackets;
    id d = 4-2*ep;

    b ep;
    print;
    .sort

*   Collect all ep dependence
    ab ep;
    .sort
    collect acc;
    normalize acc;
    b acc;
    print;
    .sort
    Keep Brackets;
    splitarg acc;
    repeat id acc(n1?, n2?, ?args) = acc(n1)*acc(n2, ?args);
    mul acc(1)*acc(ep)*acc(ep^2);
    factarg,(-1),acc;
    b acc;
    .sort
    Keep Brackets;

    id acc(ep,n1?)*acc(ep,n2?) = acc(ep,n1*n2)^2;
*   Added by Seth, guess to keep ep^2 terms?
*    id acc(ep^2,n1?)*acc(ep^2,n2?) = acc(ep^2,n1*n2)^2;
    mul epc(0,0,0);
    b acc, epc;
    .sort
    Keep Brackets;
    id acc(1)^2*epc(0,0,0) = epc(1,0,0);
    id acc(ep,n?)^2*epc(n1?,n2?,n3?) = epc(n1,n,n3);
    id acc(ep^2,n?)^2*epc(n1?,n2?,n3?) = epc(n1,n2,n);
    id acc(?args) = 1;
    
*   minimize necessary ep-dependent multiplications in final numerical
*   code by pulling ep dependent coefficient out of the whole
*   expression. 

*    b DS, TI, color, `bracketconstants', `bracketcolor', epc;
*   Collect SMEs to keep expressions smaller 
*   (change from previous bracket to avoid too large terms)
    ab fullSME;
    .sort
    collect acc;
    normalize acc;

    ab `bracketconstants';
    .sort

#if `VERSION_' >= 4
    on OldFactArg;
#endif
    cf const;
    collect const;
    normalize const;
    splitarg const;
    repeat id const(n1?,n2?,?args) = const(n1) + const(n2,?args);
    normalize const;
    factarg const;
    repeat id const(n1?,n2?,?args) = const(n1)*const(n2, ?args);
    id const(1) = 1;
    repeat;
        id const(n1?)*const(n1?) = const(n1^2);
        id const(n1?^n2?)*const(n1?^n3?) = const(n1^(n2+n3));
    endrepeat;
    repeat;
        id const(n1?)*const(n1?) = const(n1^2);
        id const(n1?^n2?)*const(n1?^n3?) = const(n1^(n2+n3));
    endrepeat;

    b DS, TI, color, `bracketconstants', `bracketcolor', const;
    print +s;
    .sort
    Keep Brackets;
    #write <`mathDir'/xsectiond`i'.m> "[xsectiond`i'] = %E;\n\n", dd`i';
    .store
    save `savDir'/xsectiond`i'.sav dd`i';
#enddo

.end
