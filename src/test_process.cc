// ///////////////////////////////////////////////////////////////////
//                                                                  //
//         T E S T   P R O G R A M                                  //
//                                                                  //
// ///////////////////////////////////////////////////////////////////

#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <cmath>

// For C++ programs, the following needs to be included in order to use
// NLOX -  the only include needed to use the generated NLOX processes.
#include "nlox_olp.h"

int main(int argc, char* argv[]) {
  ProcessConst pc;

  // The first string in argv, argv[0], is the command used to invoke
  // the program, so argc is 5 or 6 for 4 or 5 arguments given.
  if (argc > 6) {
    std::cout << "Too many input arguments!" << std::endl;
    std::cout << "Only five input arguments allowed, i.e." << std::endl;
    std::cout << "  1) the string that specifies the subprocess: initials_finals" << std::endl;
    std::cout << "  2) the string that specifies the interference type: tree_tree or tree_loop," << std::endl;
    std::cout << "  3) the string that specifies the coupling-power combination: asXaeY or gI'eJ'_gIeJ,"<< std::endl;
    std::cout << "  4) a fixed scale mu in GeV,"<< std::endl;
    std::cout << "  5) an optional 5th argument may be given: an integer 0 or 1 to"<< std::endl;
    std::cout << "  specify whether color-correlated Born MEs should be evaluated"<< std::endl;
    std::cout << "  and printed in addition (1) or not (0; default). Note that for"<< std::endl;
    std::cout << "  tree_loop there are no color-correlated Born MEs generated."<< std::endl;
    std::cout << "Abort now."<< std::endl;
    abort();
  } else if (argc < 5) {
    std::cout << "Not enough input arguments!" << std::endl;
    std::cout << "Four input arguments needed, i.e." << std::endl;
    std::cout << "  1) the string that specifies the subprocess: initials_finals" << std::endl;
    std::cout << "  2) the string that specifies the interference type: tree_tree or tree_loop," << std::endl;
    std::cout << "  3) the string that specifies the coupling-power combination: asXaeY or gI'eJ'_gIeJ," << std::endl;
    std::cout << "  4) a fixed scale mu in GeV."<< std::endl;
    std::cout << std::endl;
    std::cout << "  An optional 5th argument may be given: an integer 0 or 1 to"<< std::endl;
    std::cout << "  specify whether color-correlated Born MEs should be evaluated"<< std::endl;
    std::cout << "  and printed in addition (1) or not (0; default). Note that for"<< std::endl;
    std::cout << "  tree_loop there are no color-correlated Born MEs generated."<< std::endl;
    std::cout << "Abort now."<< std::endl;
    abort();
  }

  // //////////////////////////////////////////////////////////////////
  // PHASE SPACE POINT
  // (this is absolutely user/MC dependent, and only the form of the PSP
  // pp is relevant)

  // pp stores the phase-space point. It is an array of double precision
  // numbers of length 5 * (number of external particles).
  //
  // The elements of pp are
  //
  //    pp = [p1t, p1x, p1y, p1z, m1, p2t, p2x, ...]
  //
  // This is the format used by the BLHA2 standard. 
  //
  // NOTE: NLOX does currently not use the mass components, nor the last
  // five entries of pp.
  //
  // There may be several phase-space points listed. Comment out all but
  // the one you want to use.

  ////phase_space_point

  // Convert PSP to BLHA format.
  ////setPCM

  // //////////////////////////////////////////////////////////////////
  // NLOX

  // NLOX_OLP_Start() initializes the C++ code generated by NLOX. It should
  // only be called once. Neither argument is used.
  NLOX_OLP_Start(NULL, NULL);

  // The NLOX_OLP_EvalSubProcess* functions return the pole coefficients on
  // the level of the squared amplitude. We have:
  //
  //   NLOX_OLP_EvalSubProcess_All(&isub, pp, &next, &mu, rval, &acc);
  //   NLOX_OLP_EvalSubProcess(&isub, typ, cp, pp, &next, &mu, rval2, &acc);
  //   NLOX_OLP_EvalSubProcess_CC(&isub, typ, cp, pp, &next, &mu, rvalcc, &acc);
  //
  // The argument isub should be set to the ID of the subprocess in question. It
  // can be determined from code/nlox_process.h or the SUBPROCESSES file, in the 
  // process folder of the process archive in question.
  // 
  // The argument typ should be set to either tree_tree or tree_loop.
  // 
  // The argument cp determines the coupling-power combination: It should be set
  // to either asXaeY or gI'eJ'_gIeJ, the latter case being used if the separate
  // cp contributions to a particular asXaeY are required,  where X=(I'+I)/2 and
  // Y=(J'+J)/2, and where X+Y=next-2 for tree_tree an X+Y=next-1 for tree_loop.
  // The SUBPROCESSES file contains the possible coupling-power combinations for
  // the process at hand.
  //
  // NLOX_OLP_EvalSubProcess_All does neither take cp nor typ as input, as for a
  // given subprocess, it sums up all coupling-power combinations that exist for
  // each interference-type of that subprocess in the given process archive.
  //
  // The argument mu is a double precision number that determines the scale in 
  // GeV.
  //
  // The return argument acc is an estimator for the numerical stability of the 
  // tree_loop result for a given PSP. For NLOX_OLP_EvalSubProcess and *_All at
  // the moment it returns three values: -1. if tred reports an instability, 0.
  // if it does not, or - in case a non-zero single pole coefficient exists and
  // tred does not report -1. - the relative difference between two single pole 
  // coefficients of infrared nature, i.e. the ones of the tree_loop result and 
  // of the corresponding real-emission correction (determined from a dedicated
  // dipole implementation), in the form |tree_loop_pole/real_emission_pole|-1.
  // The return argument acc will only return the values -1. or 0.  from tred's 
  // stability check in case the requested coupling-power combination is of the
  // form gI'eJ'_gIeJ. For NLOX_OLP_EvalSubProcess_CC acc simply returns 0.
  // 
  // The argument pp is the PSP discussed above while the argument next is the 
  // number of external particles. The dimension of pp is 5*next.
  // 
  // For the various functions, the results are returned in double precision 
  // arrays of various lenghts.
  //
  // * From NLOX_OLP_EvalSubProcess_All a double precision array of dimension 4
  // is returned, named rval above, containing the double pole, single pole and
  // finite coefficients of tree_loop, and the finite coefficient of tree_tree,
  // in the form of rval[0,1,2,3]=[tree_loop double pole,tree_loop single pole, 
  // tree_loop finite,tree_tree finite], summing over all coupling-power combi-
  // nations.
  //
  // * From NLOX_OLP_EvalSubProcess a double precision array of dimension 3 is
  // returned, named rval2 above,  containing the double pole, single pole and 
  // finite coefficients - of either tree_loop or tree_tree - as rval2[0,1,2]=
  // [double pole,single pole,finite], requested for a specific coupling-power
  // combination. For tree_tree double and single pole return zero.
  //
  // * From NLOX_OLP_EvalSubProcess_CC a double precision array containing the
  // finite coefficient of the Born ME and of all color-correlated Born MEs is
  // returned, named rvalcc above. Its dimension is 1+n*(n-1)/2 for n=next ex-
  // ternal particles, where rvalcc[0]=[tree_tree finite], and where the other
  // (next^2-next)/2 elements contain the results of the color-correlated Born
  // MEs Cjk=tree_TjTk_tree, with k<j and where the color correlators TjTk are
  // inserted between the tree MEs in color space. Ti^2=C_F if i is a quark or
  // antiquark; Ti^2=C_A if i is a gluon. More specifically, rvalcc will be in
  // the form of  [tree_tree,tree_T1T2_tree,tree_T1T3_tree,...,tree_T1Tn_tree,
  // tree_T2T3_tree,tree_T2T4_tree,...,tree_T2Tn_tree,...,tree_T(n-1)Tn_tree].  

  char* sub = argv[1];
  char* typ = argv[2];
  char* cp = argv[3];

  double mu = atof(argv[4]);

  double rval2[3];
  double rval[4];
  double acc2;
  double acc;

  // For the subprocess with ID isub, compute the requested typ and cp
  NLOX_OLP_EvalSubProcess(sub, typ, cp, pp, &next, &mu, rval2, &acc2);

  std::cout << "Sub-process ID " << sub 
            << ", interference type " << typ
            << ", coupling-power combination " << cp
            << ", at a fixed scale of " << mu << " GeV:" << std::endl;
  std::cout << "rval2[0] (double pole) = " << rval2[0] << std::endl;
  std::cout << "rval2[1] (single pole) = " << rval2[1] << std::endl;
  std::cout << "rval2[2] (finite)      = " << rval2[2] << std::endl;
  std::cout << "acc = " << acc2 << std::endl;
  std::cout << std::endl;

  // For the subprocess with ID isub, for each typ compute the sum of every cp
  // that exist in the given process archive
  NLOX_OLP_EvalSubProcess_All(sub, pp, &next, &mu, rval, &acc);

  std::cout << "Sub-process ID " << sub 
            << ", at a fixed scale of " << mu << " GeV:" << std::endl;
  std::cout << "(summing all coupling-power combinations)"<< std::endl;
  std::cout << "rval[0] (tree_loop, double pole) = " << rval[0] << std::endl;
  std::cout << "rval[1] (tree_loop, single pole) = " << rval[1] << std::endl;
  std::cout << "rval[2] (tree_loop, finite)      = " << rval[2] << std::endl;
  std::cout << "rval[3] (tree_tree, finite)      = " << rval[3] << std::endl;
  std::cout << "acc = " << acc << std::endl;
  std::cout << std::endl;

  // Compute and print color-correlated Born MEs if requested
  int ccyesno = 0;
  if ( argc == 6 ) ccyesno = atoi(argv[5]);
  if ( ccyesno == 1 ) {
    double rvalcc[1+next*(next-1)/2]; // Born + (n^2-n)/2 CC Borns
    double acccc;
    // NLOX_OLP_EvalSubProcess_CC throws a warning if it is used for tree_loop.
    NLOX_OLP_EvalSubProcess_CC(sub, typ, cp, pp, &next, &mu, rvalcc, &acccc);
    
    std::cout << "Sub-process ID " << sub 
              << ", coupling-power combination " << cp
              << ", at a fixed scale of " << mu << " GeV:" << std::endl;
    std::cout << "(Born ME and color-correlated Born MEs)"<< std::endl;
    std::cout << "rvalcc[0] (tree_tree, finite) = " << rvalcc[0] << std::endl; 
    int cccounter = 1;
    for( int j=1; j<=next; j++ ) {
      for( int k=j+1; k<=next; k++ ) {
        std::cout << "rvalcc["<<cccounter<<"] (tree_T"<<j<<"T"<<k<<"_tree, finite) = " << rvalcc[cccounter] << std::endl;
        cccounter += 1;
      }
    } 
    std::cout << "acc = " << acccc << std::endl;
    std::cout << std::endl;
  }

  return 0;

}
